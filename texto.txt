#include <stdio.h>
#include <stdlib.h>

int main()
{
    FILE *fl;
    int c;

    if((fl = fopen("caminho/do/arquivo", "r")) == NULL)
    {
        perror("Erro: fopen");
        exit(EXIT_FAILURE);
    }

    while((c = fgetc(fl)) != EOF)
        printf("Caractere lido: %c\n", c);

    if((c == EOF) && (feof(fl) == 0) && (ferror(fl) != 0))
        perror("Erro: fgetc");
        

    fclose(fl);
    return EXIT_SUCCESS;
}
fgets[editar | editar código-fonte]
Ao chamar a função fgets(), você deve fornecer o ponteiro para a string onde os dados lidos devem ser guardados, além do tamanho máximo dos dados a serem lidos (para que a memória reservada à string não seja ultrapassada).
Para se ler uma string num arquivo podemos usar fgets() cujo protótipo é:

char *fgets (char *str, int tamanho,FILE *fp);
A função recebe 3 argumentos: a string a ser lida, o limite máximo de caracteres a serem lidos e o ponteiro para FILE, que está associado ao arquivo de onde a string será lida. A função lê a string até que um caracter de nova linha seja lido ou tamanho-1 caracteres tenham sido lidos. Se o caracter de nova linha ('\n') for lido, ele fará parte da string, o que não acontecia com gets.

A função fgets é semelhante à função gets(), porém, além dela poder fazer a leitura a partir de um arquivo de dados e incluir o caracter de nova linha na string, ela ainda especifica o tamanho máximo da string de entrada. Como vimos, a função gets não tinha este controle, o que poderia acarretar erros de "estouro de buffer". Portanto, levando em conta que o ponteiro fp pode ser substituído por stdin, como vimos acima, uma alternativa ao uso de gets é usar a seguinte construção:

fgets (str, tamanho, stdin);
fscanf[editar | editar código-fonte]
Sintaxe quase igual à de scanf(); só é necessário adicionar o identificador de fluxo no início.
fscanf[editar | editar código-fonte]
A função fscanf() funciona como a função scanf(). A diferença é que fscanf() lê de um arquivo e não do teclado do computador. Protótipo:

int fscanf (FILE *fp,char *str,...);
#include <stdio.h>
#include <stdlib.h>
int main()
{
   FILE *p;
   char str[80],c;
   printf("\n\n Entre com um nome para o arquivo:\n");       /* Le um nome para o arquivo a ser aberto: */
   gets(str);
   if (!(p = fopen(str,"w")))  		                     /* Caso ocorra algum erro na abertura do arquivo..*/ 
     {                           		             /* o programa aborta automaticamente */
        printf("Erro! Impossivel abrir o arquivo!\n");
        exit(1);
     }
   fprintf(p,"Este e um arquivo chamado:\n%s\n", str);
   fclose(p);                                                /* Se nao houve erro, imprime no arquivo, fecha ...*/
   p = fopen(str,"r");                                 /* abre novamente para a leitura  */
   while (!feof(p))
    {
       fscanf(p,"%c",&c);
       printf("%c",c);
    } 
   fclose(p);
   return 0;
}
fread[editar | editar código-fonte]
Essa função envolve os conceitos de ponteiro e vetor, que só serão abordados mais tarde.
Podemos escrever e ler blocos de dados. Para tanto, temos as funções fread() e fwrite(). O protótipo de fread() é:

 unsigned fread (void *buffer, int numero_de_bytes, int count, FILE *fp);
O buffer é a região de memória na qual serão armazenados os dados lidos. O número de bytes é o tamanho da unidade a ser lida. count indica quantas unidades devem ser lidas. Isto significa que o número total de bytes lidos é:

numero_de_bytes*count
A função retorna o número de unidades efetivamente lidas. Este número pode ser menor que count quando o fim do arquivo for encontrado ou ocorrer algum erro.

Quando o arquivo for aberto para dados binários, fread pode ler qualquer tipo de dados.

Movendo pelo arquivo[editar | editar código-fonte]
fseek[editar | editar código-fonte]
Para se fazer procuras e acessos randômicos em arquivos usa-se a função fseek(). Esta move a posição corrente de leitura ou escrita no arquivo de um valor especificado, a partir de um ponto especificado. Seu protótipo é:

int fseek (FILE *fp, long numbytes, int origem);
O parâmetro origem determina a partir de onde os numbytes de movimentação serão contados. Os valores possíveis são definidos por macros em stdio.h e são:

Nome         Valor   Significado
SEEK_SET        0       Início do arquivo
SEEK_CUR        1       Ponto corrente no arquivo
SEEK_END        2       Fim do arquivo
Tendo-se definido a partir de onde irá se contar, numbytes determina quantos bytes de deslocamento serão dados na posição atual.

rewind[editar | editar código-fonte]
Volta para o começo do arquivo de um fluxo

feof[editar | editar código-fonte]
EOF ("End of file") indica o fim de um arquivo. Às vezes, é necessário verificar se um arquivo chegou ao fim. Para isto podemos usar a função feof(). Ela retorna não-zero se o arquivo chegou ao EOF, caso contrário retorna zero. Seu protótipo é:

int feof (FILE *fp);
Outra forma de se verificar se o final do arquivo foi atingido é comparar o caractere lido por getc com EOF. O programa a seguir abre um arquivo já existente e o lê, caracter por caracter, até que o final do arquivo seja atingido. Os caracteres lidos são apresentados na tela: